#!/usr/bin/env python3
"""
Fixed Tableau .tds comparator that handles attribute-based <column> tags and multiple
metadata-record layouts. Keeps HTML output format unchanged.

Usage: run in environment where the two .tds files are present:
  /mnt/data/Orders Sample.tds
  /mnt/data/Orders Sample 2.tds
Output: /mnt/data/datasource_comparison_report.html
"""
import os
import xml.etree.ElementTree as ET
import html

# ---------- configuration ----------
PRE_TDS_PATH = "/mnt/data/Orders Sample.tds"
POST_TDS_PATH = "/mnt/data/Orders Sample 2.tds"
OUTPUT_HTML = "/mnt/data/datasource_comparison_report.html"

ALLOWED_DETAIL_PATHS = [
    "root/connection/relation/table",
    "root/connection/relation/text",
    "root/connection/named-connection/caption",
    "root/connection/named-connection/connection/schema",
    "root/connection/named-connection/connection/username",
    "root/object-graph/objects/object/properties/relation/table",
    "root/object-graph/objects/object/properties/relation/name",
]


# ---------- XML utilities ----------
def strip_namespace(elem):
    """Strip namespaces recursively."""
    if elem is None:
        return
    if isinstance(elem.tag, str) and elem.tag.startswith("{"):
        elem.tag = elem.tag.split("}", 1)[1]
    # attributes
    for k in list(elem.attrib.keys()):
        if k.startswith("{"):
            newk = k.split("}", 1)[1]
            elem.attrib[newk] = elem.attrib.pop(k)
    # children
    for child in list(elem):
        strip_namespace(child)


def parse_tds_file(path):
    """Parse a .tds XML file into an ElementTree root with namespaces stripped."""
    try:
        with open(path, "r", encoding="utf-8") as f:
            text = f.read()
        root = ET.fromstring(text)
        strip_namespace(root)
        return root
    except Exception as e:
        # try fallback parse
        try:
            parser = ET.XMLParser(encoding="utf-8")
            root = ET.fromstring(text.encode("utf-8"), parser=parser)
            strip_namespace(root)
            return root
        except Exception as e2:
            print(f"ERROR: Failed to parse {path}: {e2}")
            return None


# ---------- extract column info ----------
def resolve_column_key(col_elem, idx):
    """
    Resolve DB field name for <column> element. Order:
      1) child <name> text
      2) attribute 'name'
      3) child <db-field-name> text
      4) child <caption> text
      5) attribute 'caption'
      6) fallback generated __unnamed_column__N
    Also detect param-domain-type child or attribute to prefix 'Parameter_'.
    """
    # 1: child <name>
    name = (col_elem.findtext("name") or "").strip()
    # 2: attribute name
    if not name:
        name = (col_elem.get("name") or "").strip()
    # 3: db-field-name child
    if not name:
        name = (col_elem.findtext("db-field-name") or "").strip()
    # 4: caption child
    if not name:
        name = (col_elem.findtext("caption") or "").strip()
    # 5: caption attribute
    if not name:
        name = (col_elem.get("caption") or "").strip()
    # fallback
    if not name:
        name = f"__unnamed_column__{idx}"
    # check param-domain-type as child or attribute
    is_param = False
    if col_elem.find("param-domain-type") is not None:
        is_param = True
    if col_elem.get("param-domain-type"):
        is_param = True
    if is_param:
        if not name.startswith("Parameter_"):
            name = "Parameter_" + name
    return name


def get_columns(tds_root):
    """
    Return dict keyed by DB field name.
    Value: {'tableau_field_name': <caption>, 'hidden': 'Yes'|'No', 'is_parameter': bool}
    Handles both attribute-based and child-element-based column definitions.
    """
    columns = {}
    if tds_root is None:
        return columns
    idx = 0
    for col in tds_root.findall(".//column"):
        idx += 1
        key = resolve_column_key(col, idx)
        # caption: prefer child text then attribute
        caption = (col.findtext("caption") or "").strip()
        if not caption:
            caption = (col.get("caption") or "").strip()
        # hidden: attribute 'hidden' or child <hidden>
        hidden_raw = col.get("hidden")
        if hidden_raw is None:
            hidden_raw = col.findtext("hidden")
        hidden = "No"
        if hidden_raw is not None:
            hidden_l = str(hidden_raw).strip().lower()
            hidden = "Yes" if hidden_l in ("true", "1", "yes") else "No"
        # detect param domain type presence (child or attribute)
        is_parameter = bool(col.find("param-domain-type") is not None or col.get("param-domain-type"))
        columns[key] = {
            "tableau_field_name": caption,
            "hidden": hidden,
            "is_parameter": is_parameter,
        }
    return columns


# ---------- metadata extraction ----------
def get_metadata_records(tds_root):
    """
    Return dict keyed by remote-name -> {'local_name':..., 'local_type':...}
    Handles:
      - <metadata-record> child elements containing <remote-name>/<local-name>/<local-type>
      - <metadata-records><record> style
      - some fallback to attributes if any exist (defensive)
    """
    results = {}
    if tds_root is None:
        return results

    # direct <metadata-record> elements
    for rec in tds_root.findall(".//metadata-record"):
        # child element
        remote = (rec.findtext("remote-name") or "").strip()
        local = (rec.findtext("local-name") or "").strip()
        ltype = (rec.findtext("local-type") or "").strip()
        # fallback: attributes on element
        if not remote:
            remote = (rec.get("remote-name") or rec.get("remote") or "").strip()
        if not local:
            local = (rec.get("local-name") or rec.get("local") or "").strip()
        if not ltype:
            ltype = (rec.get("local-type") or rec.get("local_type") or "").strip()
        if remote:
            results[remote] = {"local_name": local, "local_type": ltype}

    # fallback layout: <metadata-records><record>
    for rec in tds_root.findall(".//metadata-records//record"):
        remote = (rec.findtext("remote-name") or "").strip()
        local = (rec.findtext("local-name") or "").strip()
        ltype = (rec.findtext("local-type") or "").strip()
        if not remote:
            remote = (rec.get("remote-name") or rec.get("remote") or rec.findtext("name") or "").strip()
        if not local:
            local = (rec.get("local-name") or rec.get("local") or "").strip()
        if not ltype:
            ltype = (rec.get("local-type") or rec.get("local_type") or "").strip()
        if remote:
            results[remote] = {"local_name": local, "local_type": ltype}

    # defensive: if still empty, try any record-like nodes that have useful tags
    # (e.g., some TDS variations might have <remote-alias> or <remote-type> etc.)
    # Do not override existing keys.
    if not results:
        for rec in tds_root.findall(".//metadata-records//*"):
            # skip if it's a tag already handled
            if rec.tag in ("remote-name", "local-name", "local-type", "record"):
                continue
            # Try to find sibling remote-name/local-name up the tree
            parent = rec
            while parent is not None and parent.tag != "metadata-records" and parent.tag != "metadata-record":
                parent = parent.getparent() if hasattr(parent, "getparent") else None
            # Can't robustly handle all exotic forms here; main formats covered above.

    return results


# ---------- XML (details) parsing ----------
def parse_inner_xml_from_tds(tds_root):
    """
    Parse the embedded <xml> block inside .tds if present, otherwise reconstruct from <connection>.
    Returns Element root or None.
    """
    if tds_root is None:
        return None
    xml_elem = tds_root.find(".//xml")
    content = None
    if xml_elem is not None and xml_elem.text and xml_elem.text.strip():
        content = xml_elem.text.strip()
    if not content:
        conn = tds_root.find(".//connection")
        if conn is not None:
            parts = []
            for child in list(conn):
                try:
                    parts.append(ET.tostring(child, encoding="utf-8").decode("utf-8", errors="replace"))
                except Exception:
                    pass
            if parts:
                content = "<root>" + "".join(parts) + "</root>"
    if not content:
        return None
    try:
        inner_root = ET.fromstring(content)
        strip_namespace(inner_root)
        return inner_root
    except Exception:
        try:
            inner_root = ET.fromstring(f"<root>{content}</root>")
            strip_namespace(inner_root)
            return inner_root
        except Exception as e:
            print(f"ERROR: Failed to parse inner xml: {e}")
            return None


def get_allowed_detail_values(inner_root):
    """Return path -> list of text values for allowed detail paths."""
    results = {p: [] for p in ALLOWED_DETAIL_PATHS}
    if inner_root is None:
        return results
    for path in ALLOWED_DETAIL_PATHS:
        parts = path.split("/")
        xpath = ".//" + "/".join(parts[1:]) if parts[0] == inner_root.tag else ".//" + "/".join(parts)
        try:
            found = inner_root.findall(xpath)
        except Exception:
            found = inner_root.findall(".//" + parts[-1])
        for elem in found:
            txt = elem.text.strip() if elem.text and elem.text.strip() else ""
            results[path].append(txt)
    return results


# ---------- comparison helpers ----------
def compare_keyed_dicts(pre_dict, post_dict):
    matches, diffs, only_pre, only_post = [], [], [], []
    pre_keys, post_keys = set(pre_dict.keys()), set(post_dict.keys())
    for k in sorted(pre_keys & post_keys):
        if pre_dict[k] == post_dict[k]:
            matches.append((k, pre_dict[k], post_dict[k]))
        else:
            diffs.append((k, pre_dict[k], post_dict[k]))
    for k in sorted(pre_keys - post_keys):
        only_pre.append((k, pre_dict[k]))
    for k in sorted(post_keys - pre_keys):
        only_post.append((k, post_dict[k]))
    return matches, diffs, only_pre, only_post


def compare_lists_by_index(pre_list, post_list):
    matches, diffs = [], []
    maxlen = max(len(pre_list), len(post_list))
    for i in range(maxlen):
        pre_val = pre_list[i] if i < len(pre_list) else None
        post_val = post_list[i] if i < len(post_list) else None
        if pre_val == post_val and pre_val is not None:
            matches.append((i, pre_val))
        else:
            diffs.append((i, pre_val, post_val))
    return matches, diffs


# ---------- HTML builders (kept layout unchanged) ----------
def build_column_tables_html(matches, diffs, only_pre, only_post, pre_label="Pre-Deployment", post_label="Post Deployment"):
    header = """
<table class="compare" border="1" cellspacing="0" cellpadding="4">
<thead>
<tr><th rowspan="2">DB Field Name</th><th colspan="2">%s</th><th colspan="2">%s</th></tr>
<tr><th>Tableau Field Name</th><th>Hidden</th><th>Tableau Field Name</th><th>Hidden</th></tr>
</thead>
<tbody>
""" % (pre_label, post_label)
    footer = "</tbody></table>"

    matches_rows = []
    for key, prev, postv in matches:
        pre_tf = html.escape(prev.get("tableau_field_name", "")) if prev else ""
        pre_hidden = html.escape(prev.get("hidden", "")) if prev else ""
        post_tf = html.escape(postv.get("tableau_field_name", "")) if postv else ""
        post_hidden = html.escape(postv.get("hidden", "")) if postv else ""
        matches_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    diffs_rows = []
    for key, prev, postv in diffs:
        pre_tf = html.escape(prev.get("tableau_field_name", "")) if prev else ""
        pre_hidden = html.escape(prev.get("hidden", "")) if prev else ""
        post_tf = html.escape(postv.get("tableau_field_name", "")) if postv else ""
        post_hidden = html.escape(postv.get("hidden", "")) if postv else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    for key, prev in only_pre:
        pre_tf = html.escape(prev.get("tableau_field_name", "")) if prev else ""
        pre_hidden = html.escape(prev.get("hidden", "")) if prev else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td></td><td></td></tr>")

    for key, postv in only_post:
        post_tf = html.escape(postv.get("tableau_field_name", "")) if postv else ""
        post_hidden = html.escape(postv.get("hidden", "")) if postv else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td></td><td></td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    matches_html = header + ("".join(matches_rows) if matches_rows else '<tr><td colspan="5"><em>No matching columns</em></td></tr>') + footer
    diffs_html = header + ("".join(diffs_rows) if diffs_rows else '<tr><td colspan="5"><em>No differences</em></td></tr>') + footer
    return matches_html, diffs_html


def build_metadata_tables_html(matches, diffs, only_pre, only_post, pre_label="Pre-Deployment", post_label="Post Deployment"):
    header = """
<table class="compare" border="1" cellspacing="0" cellpadding="4">
<thead>
<tr><th rowspan="2">DB Field Name</th><th colspan="2">%s</th><th colspan="2">%s</th></tr>
<tr><th>Tableau Remote Field Name</th><th>Data type</th><th>Tableau Remote Field Name</th><th>Data type</th></tr>
</thead>
<tbody>
""" % (pre_label, post_label)
    footer = "</tbody></table>"

    matches_rows = []
    for key, prev, postv in matches:
        pre_local = html.escape(prev.get("local_name", "")) if prev else ""
        pre_type = html.escape(prev.get("local_type", "")) if prev else ""
        post_local = html.escape(postv.get("local_name", "")) if postv else ""
        post_type = html.escape(postv.get("local_type", "")) if postv else ""
        matches_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_local}</td><td>{pre_type}</td><td>{post_local}</td><td>{post_type}</td></tr>")

    diffs_rows = []
    for key, prev, postv in diffs:
        pre_local = html.escape(prev.get("local_name", "")) if prev else ""
        pre_type = html.escape(prev.get("local_type", "")) if prev else ""
        post_local = html.escape(postv.get("local_name", "")) if postv else ""
        post_type = html.escape(postv.get("local_type", "")) if postv else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_local}</td><td>{pre_type}</td><td>{post_local}</td><td>{post_type}</td></tr>")

    for key, prev in only_pre:
        pre_local = html.escape(prev.get("local_name", "")) if prev else ""
        pre_type = html.escape(prev.get("local_type", "")) if prev else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_local}</td><td>{pre_type}</td><td></td><td></td></tr>")

    for key, postv in only_post:
        post_local = html.escape(postv.get("local_name", "")) if postv else ""
        post_type = html.escape(postv.get("local_type", "")) if postv else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td></td><td></td><td>{post_local}</td><td>{post_type}</td></tr>")

    matches_html = header + ("".join(matches_rows) if matches_rows else '<tr><td colspan="5"><em>No matching metadata</em></td></tr>') + footer
    diffs_html = header + ("".join(diffs_rows) if diffs_rows else '<tr><td colspan="5"><em>No differences</em></td></tr>') + footer
    return matches_html, diffs_html


def build_xml_tables_html(matches_by_path, diffs_by_path):
    def build_table(rows, headers=("Attribute", "Pre Deployment", "Post Deployment")):
        h = '<table border="1" cellpadding="6" cellspacing="0">'
        h += '<thead><tr>' + ''.join(f'<th>{html.escape(col)}</th>' for col in headers) + '</tr></thead><tbody>'
        if not rows:
            h += "<tr><td colspan='3'><em>No entries</em></td></tr>"
        else:
            for attr, pre, post in rows:
                h += f"<tr><td>{html.escape(attr)}</td><td>{html.escape(pre or 'Not Present')}</td><td>{html.escape(post or 'Not Present')}</td></tr>"
        h += "</tbody></table>"
        return h

    matches_rows = []
    diffs_rows = []
    for path in ALLOWED_DETAIL_PATHS:
        for idx, val in matches_by_path.get(path, []):
            attr = path if len(matches_by_path.get(path, [])) <= 1 else f"{path}[{idx}]"
            matches_rows.append((attr, val, val))
        for idx, pre, post in diffs_by_path.get(path, []):
            attr = path if len(diffs_by_path.get(path, [])) <= 1 else f"{path}[{idx}]"
            diffs_rows.append((attr, pre or "Not Present", post or "Not Present"))

    matches_html = build_table(matches_rows)
    diffs_html = build_table(diffs_rows)
    return matches_html, diffs_html


# ---------- report generation ----------
def generate_html_report(results, output_path):
    total = results.get("total", 0)
    entries = results.get("entries", [])
    matched = [e for e in entries if e["is_matched"]]
    unmatched = [e for e in entries if not e["is_matched"]]

    html_parts = []
    html_parts.append('<!doctype html><html><head><meta charset="utf-8"><title>Data source comparison report</title>')
    html_parts.append('<style> body{font-family:Arial,Helvetica,sans-serif;padding:20px} table.compare{border-collapse:collapse;width:100%;margin-bottom:10px} table.compare th{background:#eee} details{margin-bottom:6px;padding:4px} table{width:100%;border-collapse:collapse} th{background:#e6f2ff} td, th{border:1px solid #999;padding:6px}</style>')
    html_parts.append("</head><body>")
    html_parts.append("<h1>Data source comparison report</h1>")
    html_parts.append(f"<p>Total number of Data sources compared: <strong>{total}</strong><br>")
    html_parts.append(f"Total number of matched Data sources: <strong>{len(matched)}</strong><br>")
    html_parts.append(f"Total number of unmatched Data sources: <strong>{len(unmatched)}</strong></p>")

    # Unmatched
    html_parts.append("<h2>List of Unmatched Data sources</h2>")
    if unmatched:
        html_parts.append("<ol>")
        for entry in unmatched:
            name = entry["name"]
            comps = entry["comparisons"]
            html_parts.append(f'<li><details><summary>{html.escape(name)}</summary>')
            # Columns
            col = comps["columns"]
            col_matches_html, col_diffs_html = build_column_tables_html(col["matches"], col["diffs"], col["only_pre"], col["only_post"])
            html_parts.append("<h4>Column Comparison</h4>")
            html_parts.append("<details><summary>Matches</summary>")
            html_parts.append(col_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(col_diffs_html)
            html_parts.append("</details>")
            # Metadata
            md = comps["metadata"]
            md_matches_html, md_diffs_html = build_metadata_tables_html(md["matches"], md["diffs"], md["only_pre"], md["only_post"])
            html_parts.append("<h4>Metadata Comparison</h4>")
            html_parts.append("<details><summary>Matches</summary>")
            html_parts.append(md_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(md_diffs_html)
            html_parts.append("</details>")
            # XML
            xmlc = comps["xml"]
            xml_matches_html, xml_diffs_html = build_xml_tables_html(xmlc["matches_by_path"], xmlc["diffs_by_path"])
            html_parts.append("<h4>XML Comparison</h4>")
            html_parts.append("<details><summary>Matches</summary>")
            html_parts.append(xml_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(xml_diffs_html)
            html_parts.append("</details>")
            html_parts.append("</details></li>")
        html_parts.append("</ol>")
    else:
        html_parts.append("<p><em>No unmatched data sources.</em></p>")

    # Matched
    html_parts.append("<h2>List of Matched Data sources</h2>")
    if matched:
        html_parts.append("<ol>")
        for entry in matched:
            name = entry["name"]
            comps = entry["comparisons"]
            html_parts.append(f'<li><details open><summary>{html.escape(name)}</summary>')
            # Columns
            col = comps["columns"]
            col_matches_html, col_diffs_html = build_column_tables_html(col["matches"], col["diffs"], col["only_pre"], col["only_post"])
            html_parts.append("<h4>Column Comparison</h4>")
            html_parts.append("<details open><summary>Matches</summary>")
            html_parts.append(col_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(col_diffs_html)
            html_parts.append("</details>")
            # Metadata
            md = comps["metadata"]
            md_matches_html, md_diffs_html = build_metadata_tables_html(md["matches"], md["diffs"], md["only_pre"], md["only_post"])
            html_parts.append("<h4>Metadata Comparison</h4>")
            html_parts.append("<details open><summary>Matches</summary>")
            html_parts.append(md_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(md_diffs_html)
            html_parts.append("</details>")
            # XML
            xmlc = comps["xml"]
            xml_matches_html, xml_diffs_html = build_xml_tables_html(xmlc["matches_by_path"], xmlc["diffs_by_path"])
            html_parts.append("<h4>XML Comparison</h4>")
            html_parts.append("<details open><summary>Matches</summary>")
            html_parts.append(xml_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(xml_diffs_html)
            html_parts.append("</details>")
            html_parts.append("</details></li>")
        html_parts.append("</ol>")
    else:
        html_parts.append("<p><em>No matched data sources.</em></p>")

    html_parts.append("</body></html>")

    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(html_parts))
    print(f"INFO: Report written to {output_path}")


# -----------------------
# high level compare
# -----------------------
def compare_two_datasources(pre_tds_root, post_tds_root):
    pre_cols = get_columns(pre_tds_root)
    post_cols = get_columns(post_tds_root)
    col_matches, col_diffs, col_only_pre, col_only_post = compare_keyed_dicts(pre_cols, post_cols)

    pre_md = get_metadata_records(pre_tds_root)
    post_md = get_metadata_records(post_tds_root)
    md_matches, md_diffs, md_only_pre, md_only_post = compare_keyed_dicts(pre_md, post_md)

    pre_inner = parse_inner_xml_from_tds(pre_tds_root)
    post_inner = parse_inner_xml_from_tds(post_tds_root)
    pre_details = get_allowed_detail_values(pre_inner)
    post_details = get_allowed_detail_values(post_inner)

    matches_by_path, diffs_by_path = {}, {}
    for path in ALLOWED_DETAIL_PATHS:
        pre_list = pre_details.get(path, [])
        post_list = post_details.get(path, [])
        m, d = compare_lists_by_index(pre_list, post_list)
        matches_by_path[path], diffs_by_path[path] = m, d

    comparison_summary = {
        "columns": {"matches": col_matches, "diffs": col_diffs, "only_pre": col_only_pre, "only_post": col_only_post},
        "metadata": {"matches": md_matches, "diffs": md_diffs, "only_pre": md_only_pre, "only_post": md_only_post},
        "xml": {"matches_by_path": matches_by_path, "diffs_by_path": diffs_by_path},
    }

    has_col_diff = bool(col_diffs or col_only_pre or col_only_post)
    has_md_diff = bool(md_diffs or md_only_pre or md_only_post)
    has_xml_diff = any(diffs_by_path[path] for path in ALLOWED_DETAIL_PATHS)
    is_matched = not (has_col_diff or has_md_diff or has_xml_diff)

    return comparison_summary, is_matched


def collect_tdsx_files(directory):
    """Collect .tdsx files only (keeps behavior same as your previous full script)."""
    files = {}
    if not directory or not os.path.isdir(directory):
        return files
    for fname in os.listdir(directory):
        if fname.lower().endswith(".tdsx"):
            key = os.path.splitext(fname)[0]
            files[key] = os.path.join(directory, fname)
    return files


# -----------------------
# main
# -----------------------
def main():
    # For test run we will use the two uploaded .tds files directly:
    pre_root = parse_tds_file(PRE_TDS_PATH)
    post_root = parse_tds_file(POST_TDS_PATH)

    comps, is_matched = compare_two_datasources(pre_root, post_root)
    total = 1
    entries = [{"name": "Orders Sample", "comparisons": comps, "is_matched": is_matched}]
    results = {"total": total, "entries": entries}
    generate_html_report(results, OUTPUT_HTML)


if __name__ == "__main__":
    main()
