#!/usr/bin/env python3
"""
Full end-to-end Tableau datasource comparator.

- Hard-coded directories (edit in main()) for pre/post .tdsx files.
- Extracts .tds from .tdsx, parses, compares columns, metadata, and allowed XML details.
- Robust extraction: reads attribute-based and child-element-based formats for <column>.
- Robust metadata extraction across common .tds layouts.
- Generates HTML report (same layout you requested) and opens it automatically.
"""
import os
import zipfile
import xml.etree.ElementTree as ET
import html
import webbrowser

# ----------------------------
# Configuration - edit if needed
# ----------------------------
PRE_DIR = r"C:\Users\mr05197\PycharmProjects\pythonProject\Full Volume Release\Downloaded Content\ISTD - 31"
POST_DIR = r"C:\Users\mr05197\PycharmProjects\pythonProject\Full Volume Release\Downloaded Content\STD - FR"
OUTPUT_HTML = os.path.abspath("datasource_comparison_report.html")
# ----------------------------

ALLOWED_DETAIL_PATHS = [
    "root/connection/relation/table",
    "root/connection/relation/text",
    "root/connection/named-connection/caption",
    "root/connection/named-connection/connection/schema",
    "root/connection/named-connection/connection/username",
    "root/object-graph/objects/object/properties/relation/table",
    "root/object-graph/objects/object/properties/relation/name",
]


# ----------------------------
# XML utility helpers
# ----------------------------
def strip_namespace(elem):
    """Remove XML namespace prefixes from tags & attributes recursively."""
    if elem is None:
        return
    if isinstance(elem.tag, str) and elem.tag.startswith("{"):
        elem.tag = elem.tag.split("}", 1)[1]
    for k in list(elem.attrib.keys()):
        if k.startswith("{"):
            newk = k.split("}", 1)[1]
            elem.attrib[newk] = elem.attrib.pop(k)
    for child in list(elem):
        strip_namespace(child)


def extract_tds_from_tdsx(tdsx_path):
    """Return .tds file contents (first .tds found) from a .tdsx package or None if not found."""
    if not tdsx_path or not os.path.exists(tdsx_path):
        return None
    try:
        with zipfile.ZipFile(tdsx_path, "r") as z:
            for name in z.namelist():
                if name.lower().endswith(".tds"):
                    with z.open(name) as f:
                        data = f.read()
                        return data.decode("utf-8", errors="replace")
    except Exception as e:
        print(f"ERROR: Unable to open {tdsx_path}: {e}")
    return None


def parse_tds_from_string(tds_str):
    """Parse XML string to Element root. Strip namespaces. Return None on failure."""
    if not tds_str:
        return None
    try:
        root = ET.fromstring(tds_str)
        strip_namespace(root)
        return root
    except Exception:
        try:
            parser = ET.XMLParser(encoding="utf-8")
            root = ET.fromstring(tds_str.encode("utf-8"), parser=parser)
            strip_namespace(root)
            return root
        except Exception as e:
            print(f"ERROR: Failed parsing TDS XML: {e}")
            return None


# ----------------------------
# Column extraction (robust)
# ----------------------------
def resolve_column_key(col_elem, idx):
    """
    Resolve DB field identifier for a <column> element.
    Resolution order:
      1) child <name> text
      2) attribute 'name'
      3) child <db-field-name> text
      4) child <caption> text
      5) attribute 'caption'
      6) fallback generated __unnamed_column__N
    Also detects param-domain-type as child or attribute and prefixes 'Parameter_'.
    """
    name = (col_elem.findtext("name") or "").strip()
    if not name:
        name = (col_elem.get("name") or "").strip()
    if not name:
        name = (col_elem.findtext("db-field-name") or "").strip()
    if not name:
        name = (col_elem.findtext("caption") or "").strip()
    if not name:
        name = (col_elem.get("caption") or "").strip()
    if not name:
        name = f"__unnamed_column__{idx}"
    # param detection
    is_param = (col_elem.find("param-domain-type") is not None) or bool(col_elem.get("param-domain-type"))
    if is_param and not name.startswith("Parameter_"):
        name = "Parameter_" + name
    return name


def get_columns(tds_root):
    """
    Return dict keyed by DB field name.
    Value: {'tableau_field_name': caption, 'hidden': 'Yes'/'No', 'is_parameter': bool}
    Handles attribute-based and child-element formats.
    """
    columns = {}
    if tds_root is None:
        return columns
    idx = 0
    for col in tds_root.findall(".//column"):
        idx += 1
        key = resolve_column_key(col, idx)
        # caption - prefer child text then attribute
        caption = (col.findtext("caption") or "").strip()
        if not caption:
            caption = (col.get("caption") or "").strip()
        # hidden - attribute or child
        hidden_raw = col.get("hidden")
        if hidden_raw is None:
            hidden_raw = col.findtext("hidden")
        hidden = "No"
        if hidden_raw is not None:
            hidden_l = str(hidden_raw).strip().lower()
            hidden = "Yes" if hidden_l in ("true", "1", "yes") else "No"
        is_parameter = bool(col.find("param-domain-type") is not None or col.get("param-domain-type"))
        columns[key] = {"tableau_field_name": caption, "hidden": hidden, "is_parameter": is_parameter}
    return columns


# ----------------------------
# Metadata extraction (robust)
# ----------------------------
def get_metadata_records(tds_root):
    """
    Return dict keyed by remote-name -> {'local_name':..., 'local_type':...}
    Supports:
      - direct <metadata-record> elements with child tags
      - <metadata-records><record> layout
      - fallback to attributes on elements where used
    """
    results = {}
    if tds_root is None:
        return results

    # try direct metadata-record nodes
    for rec in tds_root.findall(".//metadata-record"):
        remote = (rec.findtext("remote-name") or "").strip()
        local = (rec.findtext("local-name") or "").strip()
        ltype = (rec.findtext("local-type") or "").strip()
        # fallback to attributes if present
        if not remote:
            remote = (rec.get("remote-name") or rec.get("remote") or "").strip()
        if not local:
            local = (rec.get("local-name") or rec.get("local") or "").strip()
        if not ltype:
            ltype = (rec.get("local-type") or rec.get("local_type") or "").strip()
        if remote:
            results[remote] = {"local_name": local, "local_type": ltype}

    # fallback: metadata-records/record
    for rec in tds_root.findall(".//metadata-records//record"):
        remote = (rec.findtext("remote-name") or "").strip()
        local = (rec.findtext("local-name") or "").strip()
        ltype = (rec.findtext("local-type") or "").strip()
        if not remote:
            remote = (rec.get("remote-name") or rec.get("remote") or rec.findtext("name") or "").strip()
        if not local:
            local = (rec.get("local-name") or rec.get("local") or "").strip()
        if not ltype:
            ltype = (rec.get("local-type") or rec.get("local_type") or "").strip()
        if remote:
            results[remote] = {"local_name": local, "local_type": ltype}

    return results


# ----------------------------
# XML details parsing (inner xml)
# ----------------------------
def parse_inner_xml_from_tds(tds_root):
    """Return parsed inner XML root from <xml> block or reconstructed from <connection> children."""
    if tds_root is None:
        return None
    xml_elem = tds_root.find(".//xml")
    content = None
    if xml_elem is not None and xml_elem.text and xml_elem.text.strip():
        content = xml_elem.text.strip()
    if not content:
        # reconstruct basic XML from connection children if available
        conn = tds_root.find(".//connection")
        if conn is not None:
            parts = []
            for child in list(conn):
                try:
                    parts.append(ET.tostring(child, encoding="utf-8").decode("utf-8", errors="replace"))
                except Exception:
                    pass
            if parts:
                content = "<root>" + "".join(parts) + "</root>"
    if not content:
        return None
    try:
        inner_root = ET.fromstring(content)
        strip_namespace(inner_root)
        return inner_root
    except Exception:
        try:
            inner_root = ET.fromstring(f"<root>{content}</root>")
            strip_namespace(inner_root)
            return inner_root
        except Exception as e:
            print(f"ERROR: Failed to parse inner xml: {e}")
            return None


def get_allowed_detail_values(inner_root):
    """Extract text values for each allowed detail path; returns dict path->list(values)."""
    results = {p: [] for p in ALLOWED_DETAIL_PATHS}
    if inner_root is None:
        return results
    for path in ALLOWED_DETAIL_PATHS:
        parts = path.split("/")
        xpath = ".//" + "/".join(parts[1:]) if parts[0] == inner_root.tag else ".//" + "/".join(parts)
        try:
            found = inner_root.findall(xpath)
        except Exception:
            found = inner_root.findall(".//" + parts[-1])
        for elem in found:
            text = elem.text.strip() if elem.text and elem.text.strip() else ""
            results[path].append(text)
    return results


# ----------------------------
# comparison helpers
# ----------------------------
def compare_keyed_dicts(pre_dict, post_dict):
    matches, diffs, only_pre, only_post = [], [], [], []
    pre_keys, post_keys = set(pre_dict.keys()), set(post_dict.keys())
    for k in sorted(pre_keys & post_keys):
        if pre_dict[k] == post_dict[k]:
            matches.append((k, pre_dict[k], post_dict[k]))
        else:
            diffs.append((k, pre_dict[k], post_dict[k]))
    for k in sorted(pre_keys - post_keys):
        only_pre.append((k, pre_dict[k]))
    for k in sorted(post_keys - pre_keys):
        only_post.append((k, post_dict[k]))
    return matches, diffs, only_pre, only_post


def compare_lists_by_index(pre_list, post_list):
    matches, diffs = [], []
    maxlen = max(len(pre_list), len(post_list))
    for i in range(maxlen):
        pre_val = pre_list[i] if i < len(pre_list) else None
        post_val = post_list[i] if i < len(post_list) else None
        if pre_val == post_val and pre_val is not None:
            matches.append((i, pre_val))
        else:
            diffs.append((i, pre_val, post_val))
    return matches, diffs


# ----------------------------
# HTML builders (kept layout unchanged)
# ----------------------------
def build_column_tables_html(matches, diffs, only_pre, only_post, pre_label="Pre-Deployment", post_label="Post Deployment"):
    header = """
<table class="compare" border="1" cellspacing="0" cellpadding="4">
<thead>
<tr><th rowspan="2">DB Field Name</th><th colspan="2">%s</th><th colspan="2">%s</th></tr>
<tr><th>Tableau Field Name</th><th>Hidden</th><th>Tableau Field Name</th><th>Hidden</th></tr>
</thead>
<tbody>
""" % (pre_label, post_label)
    footer = "</tbody></table>"

    matches_rows = []
    for key, prev, postv in matches:
        pre_tf = html.escape(prev.get("tableau_field_name", "")) if prev else ""
        pre_hidden = html.escape(prev.get("hidden", "")) if prev else ""
        post_tf = html.escape(postv.get("tableau_field_name", "")) if postv else ""
        post_hidden = html.escape(postv.get("hidden", "")) if postv else ""
        matches_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    diffs_rows = []
    for key, prev, postv in diffs:
        pre_tf = html.escape(prev.get("tableau_field_name", "")) if prev else ""
        pre_hidden = html.escape(prev.get("hidden", "")) if prev else ""
        post_tf = html.escape(postv.get("tableau_field_name", "")) if postv else ""
        post_hidden = html.escape(postv.get("hidden", "")) if postv else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    for key, prev in only_pre:
        pre_tf = html.escape(prev.get("tableau_field_name", "")) if prev else ""
        pre_hidden = html.escape(prev.get("hidden", "")) if prev else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td></td><td></td></tr>")

    for key, postv in only_post:
        post_tf = html.escape(postv.get("tableau_field_name", "")) if postv else ""
        post_hidden = html.escape(postv.get("hidden", "")) if postv else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td></td><td></td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    matches_html = header + ("".join(matches_rows) if matches_rows else '<tr><td colspan="5"><em>No matching columns</em></td></tr>') + footer
    diffs_html = header + ("".join(diffs_rows) if diffs_rows else '<tr><td colspan="5"><em>No differences</em></td></tr>') + footer
    return matches_html, diffs_html


def build_metadata_tables_html(matches, diffs, only_pre, only_post, pre_label="Pre-Deployment", post_label="Post Deployment"):
    header = """
<table class="compare" border="1" cellspacing="0" cellpadding="4">
<thead>
<tr><th rowspan="2">DB Field Name</th><th colspan="2">%s</th><th colspan="2">%s</th></tr>
<tr><th>Tableau Remote Field Name</th><th>Data type</th><th>Tableau Remote Field Name</th><th>Data type</th></tr>
</thead>
<tbody>
""" % (pre_label, post_label)
    footer = "</tbody></table>"

    matches_rows = []
    for key, prev, postv in matches:
        pre_local = html.escape(prev.get("local_name", "")) if prev else ""
        pre_type = html.escape(prev.get("local_type", "")) if prev else ""
        post_local = html.escape(postv.get("local_name", "")) if postv else ""
        post_type = html.escape(postv.get("local_type", "")) if postv else ""
        matches_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_local}</td><td>{pre_type}</td><td>{post_local}</td><td>{post_type}</td></tr>")

    diffs_rows = []
    for key, prev, postv in diffs:
        pre_local = html.escape(prev.get("local_name", "")) if prev else ""
        pre_type = html.escape(prev.get("local_type", "")) if prev else ""
        post_local = html.escape(postv.get("local_name", "")) if postv else ""
        post_type = html.escape(postv.get("local_type", "")) if postv else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_local}</td><td>{pre_type}</td><td>{post_local}</td><td>{post_type}</td></tr>")

    for key, prev in only_pre:
        pre_local = html.escape(prev.get("local_name", "")) if prev else ""
        pre_type = html.escape(prev.get("local_type", "")) if prev else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_local}</td><td>{pre_type}</td><td></td><td></td></tr>")

    for key, postv in only_post:
        post_local = html.escape(postv.get("local_name", "")) if postv else ""
        post_type = html.escape(postv.get("local_type", "")) if postv else ""
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td></td><td></td><td>{post_local}</td><td>{post_type}</td></tr>")

    matches_html = header + ("".join(matches_rows) if matches_rows else '<tr><td colspan="5"><em>No matching metadata</em></td></tr>') + footer
    diffs_html = header + ("".join(diffs_rows) if diffs_rows else '<tr><td colspan="5"><em>No differences</em></td></tr>') + footer
    return matches_html, diffs_html


def build_xml_tables_html(matches_by_path, diffs_by_path):
    def build_table(rows, headers=("Attribute", "Pre Deployment", "Post Deployment")):
        h = '<table border="1" cellpadding="6" cellspacing="0">'
        h += '<thead><tr>' + ''.join(f'<th>{html.escape(col)}</th>' for col in headers) + '</tr></thead><tbody>'
        if not rows:
            h += f'<tr><td colspan="{len(headers)}"><em>No entries</em></td></tr>'
        else:
            for attr, pre, post in rows:
                h += f'<tr><td>{html.escape(attr)}</td><td>{html.escape(pre or "Not Present")}</td><td>{html.escape(post or "Not Present")}</td></tr>'
        h += "</tbody></table>"
        return h

    matches_rows = []
    diffs_rows = []
    for path in ALLOWED_DETAIL_PATHS:
        for idx, val in matches_by_path.get(path, []):
            attr = path if len(matches_by_path.get(path, [])) <= 1 else f"{path}[{idx}]"
            matches_rows.append((attr, val, val))
        for idx, pre, post in diffs_by_path.get(path, []):
            attr = path if len(diffs_by_path.get(path, [])) <= 1 else f"{path}[{idx}]"
            diffs_rows.append((attr, pre or "Not Present", post or "Not Present"))

    matches_html = build_table(matches_rows)
    diffs_html = build_table(diffs_rows)
    return matches_html, diffs_html


# ----------------------------
# Report generation
# ----------------------------
def generate_html_report(results, output_path):
    total = results.get("total", 0)
    entries = results.get("entries", [])
    matched = [e for e in entries if e["is_matched"]]
    unmatched = [e for e in entries if not e["is_matched"]]

    html_parts = []
    html_parts.append('<!doctype html><html><head><meta charset="utf-8"><title>Data source comparison report</title>')
    html_parts.append('<style> body{font-family:Arial,Helvetica,sans-serif;padding:20px} table.compare{border-collapse:collapse;width:100%;margin-bottom:10px} table.compare th{background:#eee} details{margin-bottom:6px;padding:4px} table{width:100%;border-collapse:collapse} th{background:#e6f2ff} td, th{border:1px solid #999;padding:6px}</style>')
    html_parts.append("</head><body>")
    html_parts.append("<h1>Data source comparison report</h1>")
    html_parts.append(f"<p>Total number of Data sources compared: <strong>{total}</strong><br>")
    html_parts.append(f"Total number of matched Data sources: <strong>{len(matched)}</strong><br>")
    html_parts.append(f"Total number of unmatched Data sources: <strong>{len(unmatched)}</strong></p>")

    # Unmatched
    html_parts.append("<h2>List of Unmatched Data sources</h2>")
    if unmatched:
        html_parts.append("<ol>")
        for entry in unmatched:
            name = entry["name"]
            comps = entry["comparisons"]
            html_parts.append(f'<li><details><summary>{html.escape(name)}</summary>')
            # Columns
            col = comps["columns"]
            col_matches_html, col_diffs_html = build_column_tables_html(col["matches"], col["diffs"], col["only_pre"], col["only_post"])
            html_parts.append("<h4>Column Comparison</h4>")
            html_parts.append("<details><summary>Matches</summary>")
            html_parts.append(col_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(col_diffs_html)
            html_parts.append("</details>")
            # Metadata
            md = comps["metadata"]
            md_matches_html, md_diffs_html = build_metadata_tables_html(md["matches"], md["diffs"], md["only_pre"], md["only_post"])
            html_parts.append("<h4>Metadata Comparison</h4>")
            html_parts.append("<details><summary>Matches</summary>")
            html_parts.append(md_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(md_diffs_html)
            html_parts.append("</details>")
            # XML
            xmlc = comps["xml"]
            xml_matches_html, xml_diffs_html = build_xml_tables_html(xmlc["matches_by_path"], xmlc["diffs_by_path"])
            html_parts.append("<h4>XML Comparison</h4>")
            html_parts.append("<details><summary>Matches</summary>")
            html_parts.append(xml_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(xml_diffs_html)
            html_parts.append("</details>")
            html_parts.append("</details></li>")
        html_parts.append("</ol>")
    else:
        html_parts.append("<p><em>No unmatched data sources.</em></p>")

    # Matched
    html_parts.append("<h2>List of Matched Data sources</h2>")
    if matched:
        html_parts.append("<ol>")
        for entry in matched:
            name = entry["name"]
            comps = entry["comparisons"]
            html_parts.append(f'<li><details open><summary>{html.escape(name)}</summary>')
            # Columns
            col = comps["columns"]
            col_matches_html, col_diffs_html = build_column_tables_html(col["matches"], col["diffs"], col["only_pre"], col["only_post"])
            html_parts.append("<h4>Column Comparison</h4>")
            html_parts.append("<details open><summary>Matches</summary>")
            html_parts.append(col_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(col_diffs_html)
            html_parts.append("</details>")
            # Metadata
            md = comps["metadata"]
            md_matches_html, md_diffs_html = build_metadata_tables_html(md["matches"], md["diffs"], md["only_pre"], md["only_post"])
            html_parts.append("<h4>Metadata Comparison</h4>")
            html_parts.append("<details open><summary>Matches</summary>")
            html_parts.append(md_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(md_diffs_html)
            html_parts.append("</details>")
            # XML
            xmlc = comps["xml"]
            xml_matches_html, xml_diffs_html = build_xml_tables_html(xmlc["matches_by_path"], xmlc["diffs_by_path"])
            html_parts.append("<h4>XML Comparison</h4>")
            html_parts.append("<details open><summary>Matches</summary>")
            html_parts.append(xml_matches_html)
            html_parts.append("</details>")
            html_parts.append("<details><summary>Differences</summary>")
            html_parts.append(xml_diffs_html)
            html_parts.append("</details>")
            html_parts.append("</details></li>")
        html_parts.append("</ol>")
    else:
        html_parts.append("<p><em>No matched data sources.</em></p>")

    html_parts.append("</body></html>")

    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(html_parts))
    print(f"INFO: Wrote report to {output_path}")


# ----------------------------
# High-level comparison flow
# ----------------------------
def compare_two_datasources(pre_tds_root, post_tds_root):
    # columns
    pre_cols = get_columns(pre_tds_root)
    post_cols = get_columns(post_tds_root)
    col_matches, col_diffs, col_only_pre, col_only_post = compare_keyed_dicts(pre_cols, post_cols)

    # metadata
    pre_md = get_metadata_records(pre_tds_root)
    post_md = get_metadata_records(post_tds_root)
    md_matches, md_diffs, md_only_pre, md_only_post = compare_keyed_dicts(pre_md, post_md)

    # xml details
    pre_inner = parse_inner_xml_from_tds(pre_tds_root)
    post_inner = parse_inner_xml_from_tds(post_tds_root)
    pre_details = get_allowed_detail_values(pre_inner)
    post_details = get_allowed_detail_values(post_inner)

    matches_by_path, diffs_by_path = {}, {}
    for path in ALLOWED_DETAIL_PATHS:
        pre_list = pre_details.get(path, [])
        post_list = post_details.get(path, [])
        m, d = compare_lists_by_index(pre_list, post_list)
        matches_by_path[path], diffs_by_path[path] = m, d

    comparison_summary = {
        "columns": {"matches": col_matches, "diffs": col_diffs, "only_pre": col_only_pre, "only_post": col_only_post},
        "metadata": {"matches": md_matches, "diffs": md_diffs, "only_pre": md_only_pre, "only_post": md_only_post},
        "xml": {"matches_by_path": matches_by_path, "diffs_by_path": diffs_by_path},
    }

    has_col_diff = bool(col_diffs or col_only_pre or col_only_post)
    has_md_diff = bool(md_diffs or md_only_pre or md_only_post)
    has_xml_diff = any(diffs_by_path[path] for path in ALLOWED_DETAIL_PATHS)
    is_matched = not (has_col_diff or has_md_diff or has_xml_diff)

    return comparison_summary, is_matched


# ----------------------------
# helpers reused
# ----------------------------
def compare_keyed_dicts(pre_dict, post_dict):
    matches, diffs, only_pre, only_post = [], [], [], []
    pre_keys, post_keys = set(pre_dict.keys()), set(post_dict.keys())
    for k in sorted(pre_keys & post_keys):
        if pre_dict[k] == post_dict[k]:
            matches.append((k, pre_dict[k], post_dict[k]))
        else:
            diffs.append((k, pre_dict[k], post_dict[k]))
    for k in sorted(pre_keys - post_keys):
        only_pre.append((k, pre_dict[k]))
    for k in sorted(post_keys - pre_keys):
        only_post.append((k, post_dict[k]))
    return matches, diffs, only_pre, only_post


# ----------------------------
# File collection
# ----------------------------
def collect_tdsx_files(directory):
    """Return dict basename->fullpath for .tdsx files in directory."""
    files = {}
    if not directory or not os.path.isdir(directory):
        return files
    for fname in os.listdir(directory):
        if fname.lower().endswith(".tdsx"):
            key = os.path.splitext(fname)[0]
            files[key] = os.path.join(directory, fname)
    return files


# ----------------------------
# Main
# ----------------------------
def main():
    pre_files = collect_tdsx_files(PRE_DIR)
    post_files = collect_tdsx_files(POST_DIR)
    print(f"DEBUG: Pre files={len(pre_files)} Post files={len(post_files)}")
    all_keys = sorted(set(pre_files.keys()) | set(post_files.keys()))
    total = len(all_keys)
    entries = []

    for key in all_keys:
        pre_path = pre_files.get(key)
        post_path = post_files.get(key)
        print(f"DEBUG: Processing '{key}': pre={bool(pre_path)} post={bool(post_path)}")

        pre_root = None
        post_root = None

        if pre_path:
            tds_str = extract_tds_from_tdsx(pre_path)
            if tds_str is None:
                print(f"DEBUG: Could not extract .tds from pre: {pre_path}")
            pre_root = parse_tds_from_string(tds_str) if tds_str else None

        if post_path:
            tds_str = extract_tds_from_tdsx(post_path)
            if tds_str is None:
                print(f"DEBUG: Could not extract .tds from post: {post_path}")
            post_root = parse_tds_from_string(tds_str) if tds_str else None

        # Compare (works even if one side is None)
        comps, is_matched = compare_two_datasources(pre_root, post_root)
        entries.append({"name": key, "comparisons": comps, "is_matched": is_matched})

    matched_count = sum(1 for e in entries if e["is_matched"])
    unmatched_count = sum(1 for e in entries if not e["is_matched"])
    print(f"DEBUG: Total={total} Matched={matched_count} Unmatched={unmatched_count}")

    results = {"total": total, "entries": entries}
    generate_html_report(results, OUTPUT_HTML)

    # open HTML automatically
    if os.path.exists(OUTPUT_HTML):
        webbrowser.open(f"file://{OUTPUT_HTML}")
        print(f"INFO: Opened report {OUTPUT_HTML}")
    else:
        print("ERROR: Report not found after generation.")


if __name__ == "__main__":
    main()
