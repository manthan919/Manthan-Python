#!/usr/bin/env python3
"""
Hard-coded end-to-end Tableau datasource comparator (updated XML details table format).

- Hard-coded pre / post directories in main() (Windows paths).
- Reads .tdsx files, extracts contained .tds XML, parses and compares:
    1) Column comparison: keyed by <name> (prefix Parameter_ when param-domain-type present),
       values: <caption>, <hidden> (default No, Yes when true).
    2) Metadata comparison: keyed by <remote-name>, values: <local-name>, <local-type>.
    3) Details (XML) comparison: only allowed paths are compared (by index/order).
- Produces HTML report "datasource_comparison_report.html". The XML details comparison
  is rendered as a single 3-column table (Attribute / Pre Deployment / Post Deployment)
  matching the screenshot you provided.
- Prints debug output to console.
"""
import os
import zipfile
import xml.etree.ElementTree as ET
import html

ALLOWED_DETAIL_PATHS = [
    "root/connection/relation/table",
    "root/connection/relation/text",
    "root/connection/named-connection/caption",
    "root/connection/named-connection/connection/schema",
    "root/connection/named-connection/connection/username",
    "root/object-graph/objects/object/properties/relation/table",
    "root/object-graph/objects/object/properties/relation/name",
]


def strip_namespace(elem):
    if elem is None:
        return
    if isinstance(elem.tag, str) and elem.tag.startswith("{"):
        elem.tag = elem.tag.split("}", 1)[1]
    for k in list(elem.attrib.keys()):
        if k.startswith('{'):
            newk = k.split('}', 1)[1]
            elem.attrib[newk] = elem.attrib.pop(k)
    for child in list(elem):
        strip_namespace(child)


def extract_tds_from_tdsx(tdsx_path):
    try:
        with zipfile.ZipFile(tdsx_path, "r") as z:
            for name in z.namelist():
                if name.lower().endswith('.tds'):
                    with z.open(name) as f:
                        data = f.read()
                        return data.decode('utf-8', errors='replace')
    except Exception as e:
        print(f"ERROR: Failed to read {tdsx_path}: {e}")
    return None


def parse_tds_from_string(tds_string):
    if not tds_string:
        return None
    try:
        root = ET.fromstring(tds_string)
        strip_namespace(root)
        return root
    except Exception:
        try:
            parser = ET.XMLParser(encoding='utf-8')
            root = ET.fromstring(tds_string.encode('utf-8'), parser=parser)
            strip_namespace(root)
            return root
        except Exception as e:
            print(f"ERROR: Failed parsing TDS XML: {e}")
            return None


def get_columns(tds_root):
    columns = {}
    if tds_root is None:
        return columns
    for col in tds_root.findall('.//column'):
        name = (col.findtext('name') or '').strip()
        if not name:
            name = (col.findtext('db-field-name') or '').strip()
        caption = (col.findtext('caption') or '').strip()
        hidden_raw = col.findtext('hidden')
        if hidden_raw is None:
            hidden = 'No'
        else:
            hidden_l = hidden_raw.strip().lower()
            hidden = 'Yes' if hidden_l in ('true', '1', 'yes') else 'No'
        is_parameter = col.find('param-domain-type') is not None
        db_field_name = f"Parameter_{name}" if is_parameter and name else (name or f"__unnamed_column__{len(columns)+1}")
        columns[db_field_name] = {'tableau_field_name': caption, 'hidden': hidden, 'is_parameter': is_parameter}
    return columns


def get_metadata_records(tds_root):
    results = {}
    if tds_root is None:
        return results
    for rec in tds_root.findall('.//metadata-record'):
        remote_name = (rec.findtext('remote-name') or '').strip()
        local_name = (rec.findtext('local-name') or '').strip()
        local_type = (rec.findtext('local-type') or '').strip()
        if remote_name:
            results[remote_name] = {'local_name': local_name, 'local_type': local_type}
    if not results:
        for rec in tds_root.findall('.//metadata-records//record'):
            remote_name = (rec.findtext('remote-name') or '').strip()
            local_name = (rec.findtext('local-name') or '').strip()
            local_type = (rec.findtext('local-type') or '').strip()
            if remote_name:
                results[remote_name] = {'local_name': local_name, 'local_type': local_type}
    return results


def parse_inner_xml_from_tds(tds_root):
    if tds_root is None:
        return None
    xml_elem = tds_root.find('.//xml')
    content = None
    if xml_elem is not None and xml_elem.text and xml_elem.text.strip():
        content = xml_elem.text.strip()
    if not content:
        conn = tds_root.find('.//connection')
        if conn is not None:
            parts = []
            for child in list(conn):
                try:
                    parts.append(ET.tostring(child, encoding='utf-8').decode('utf-8', errors='replace'))
                except Exception:
                    pass
            if parts:
                content = '<root>' + ''.join(parts) + '</root>'
    if not content:
        return None
    try:
        inner_root = ET.fromstring(content)
        strip_namespace(inner_root)
        return inner_root
    except Exception:
        try:
            inner_root = ET.fromstring(f"<root>{content}</root>")
            strip_namespace(inner_root)
            return inner_root
        except Exception as e:
            print(f"ERROR: Failed to parse inner xml: {e}")
            return None


def get_allowed_detail_values(inner_root):
    results = {p: [] for p in ALLOWED_DETAIL_PATHS}
    if inner_root is None:
        return results
    for path in ALLOWED_DETAIL_PATHS:
        parts = path.split('/')
        xpath = './/' + '/'.join(parts[1:]) if parts[0] == inner_root.tag else './/' + '/'.join(parts)
        try:
            found = inner_root.findall(xpath)
        except Exception:
            found = inner_root.findall('.//' + parts[-1])
        for elem in found:
            text = elem.text.strip() if elem.text and elem.text.strip() else ''
            results[path].append(text)
    return results


def compare_keyed_dicts(pre_dict, post_dict):
    matches, diffs, only_pre, only_post = [], [], [], []
    pre_keys, post_keys = set(pre_dict.keys()), set(post_dict.keys())
    for k in sorted(pre_keys & post_keys):
        if pre_dict[k] == post_dict[k]:
            matches.append((k, pre_dict[k], post_dict[k]))
        else:
            diffs.append((k, pre_dict[k], post_dict[k]))
    for k in sorted(pre_keys - post_keys):
        only_pre.append((k, pre_dict[k]))
    for k in sorted(post_keys - pre_keys):
        only_post.append((k, post_dict[k]))
    return matches, diffs, only_pre, only_post


def compare_lists_by_index(pre_list, post_list):
    matches, diffs = [], []
    maxlen = max(len(pre_list), len(post_list))
    for i in range(maxlen):
        pre_val = pre_list[i] if i < len(pre_list) else None
        post_val = post_list[i] if i < len(post_list) else None
        if pre_val == post_val and pre_val is not None:
            matches.append((i, pre_val))
        else:
            diffs.append((i, pre_val, post_val))
    return matches, diffs


def build_column_tables_html(matches, diffs, only_pre, only_post, pre_label='Pre-Deployment', post_label='Post Deployment'):
    header = '''
<table class="compare" border="1" cellspacing="0" cellpadding="4">
<thead>
<tr><th rowspan="2">DB Field Name</th><th colspan="2">%s</th><th colspan="2">%s</th></tr>
<tr><th>Tableau Field Name</th><th>Hidden</th><th>Tableau Field Name</th><th>Hidden</th></tr>
</thead>
<tbody>
''' % (pre_label, post_label)
    footer = '</tbody></table>'

    matches_rows = []
    for key, prev, postv in matches:
        pre_tf = html.escape(prev.get('tableau_field_name', ''))
        pre_hidden = html.escape(prev.get('hidden', ''))
        post_tf = html.escape(postv.get('tableau_field_name', ''))
        post_hidden = html.escape(postv.get('hidden', ''))
        matches_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    diffs_rows = []
    for key, prev, postv in diffs:
        pre_tf = html.escape(prev.get('tableau_field_name', '')) if prev else ''
        pre_hidden = html.escape(prev.get('hidden', '')) if prev else ''
        post_tf = html.escape(postv.get('tableau_field_name', '')) if postv else ''
        post_hidden = html.escape(postv.get('hidden', '')) if postv else ''
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td>{post_tf}</td><td>{post_hidden}</td></tr>")
    for key, prev in only_pre:
        pre_tf = html.escape(prev.get('tableau_field_name',''))
        pre_hidden = html.escape(prev.get('hidden',''))
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td></td><td></td></tr>")
    for key, postv in only_post:
        post_tf = html.escape(postv.get('tableau_field_name',''))
        post_hidden = html.escape(postv.get('hidden',''))
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td></td><td></td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    matches_html = header + (''.join(matches_rows) if matches_rows else '<tr><td colspan="5"><em>No matching columns</em></td></tr>') + footer
    diffs_html = header + (''.join(diffs_rows) if diffs_rows else '<tr><td colspan="5"><em>No differences</em></td></tr>') + footer
    return matches_html, diffs_html


def build_metadata_tables_html(matches, diffs, only_pre, only_post, pre_label='Pre-Deployment', post_label='Post Deployment'):
    header = '''
<table class="compare" border="1" cellspacing="0" cellpadding="4">
<thead>
<tr><th rowspan="2">DB Field Name</th><th colspan="2">%s</th><th colspan="2">%s</th></tr>
<tr><th>Tableau Remote Field Name</th><th>Data type</th><th>Tableau Remote Field Name</th><th>Data type</th></tr>
</thead>
<tbody>
''' % (pre_label, post_label)
    footer = '</tbody></table>'

    matches_rows = []
    for key, prev, postv in matches:
        matches_rows.append(f"<tr><td>{html.escape(key)}</td><td>{html.escape(prev.get('local_name',''))}</td><td>{html.escape(prev.get('local_type',''))}</td><td>{html.escape(postv.get('local_name',''))}</td><td>{html.escape(postv.get('local_type',''))}</td></tr>")

    diffs_rows = []
    for key, prev, postv in diffs:
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{html.escape(prev.get('local_name',''))}</td><td>{html.escape(prev.get('local_type',''))}</td><td>{html.escape(postv.get('local_name',''))}</td><td>{html.escape(postv.get('local_type',''))}</td></tr>")
    for key, prev in only_pre:
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{html.escape(prev.get('local_name',''))}</td><td>{html.escape(prev.get('local_type',''))}</td><td></td><td></td></tr>")
    for key, postv in only_post:
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td></td><td></td><td>{html.escape(postv.get('local_name',''))}</td><td>{html.escape(postv.get('local_type',''))}</td></tr>")

    matches_html = header + (''.join(matches_rows) if matches_rows else '<tr><td colspan="5"><em>No matching metadata</em></td></tr>') + footer
    diffs_html = header + (''.join(diffs_rows) if diffs_rows else '<tr><td colspan="5"><em>No differences</em></td></tr>') + footer
    return matches_html, diffs_html


def build_xml_tables_html(matches_by_path, diffs_by_path):
    """Build single 3-column tables for XML details: Attribute | Pre Deployment | Post Deployment

    For each allowed path we iterate through the max number of occurrences and create rows.
    Matches and Differences are both presented; Matches table will show rows where values are equal,
    Differences table will show rows where pre != post (or one side missing)."""
    def build_table(rows, headers=("Attribute", "Pre Deployment", "Post Deployment")):
        h = '<table border="1" cellpadding="6" cellspacing="0' + '">'
        h += '<thead><tr>' + ''.join(f'<th>{html.escape(col)}</th>' for col in headers) + '</tr></thead><tbody>'
        if not rows:
            h += f'<tr><td colspan="3"><em>No entries</em></td></tr>'
        else:
            for r in rows:
                attr, pre, post = r
                h += f'<tr><td>{html.escape(attr)}</td><td>{html.escape(pre or "Not Present")}</td><td>{html.escape(post or "Not Present")}</td></tr>'
        h += '</tbody></table>'
        return h

    matches_rows = []
    diffs_rows = []
    for path in ALLOWED_DETAIL_PATHS:
        pre_list = [v for (i, v) in matches_by_path.get(path, [])] if matches_by_path.get(path) else []
        post_list = []  # not needed for matches_rows since matches_by_path already holds equal values
        # For diffs, use diffs_by_path
        diffs = diffs_by_path.get(path, [])
        # Build matches rows from matches_by_path
        for idx, val in matches_by_path.get(path, []):
            # Attribute should be path (optionally with index if multiple)
            attr = path if len(matches_by_path.get(path, [])) <= 1 else f"{path}[{idx}]"
            matches_rows.append((attr, val, val))
        # Build diffs rows
        for idx, pre, post in diffs:
            attr = path if len(diffs) <= 1 else f"{path}[{idx}]"
            diffs_rows.append((attr, pre or 'Not Present', post or 'Not Present'))

    matches_html = build_table(matches_rows)
    diffs_html = build_table(diffs_rows)
    return matches_html, diffs_html


def generate_html_report(results, output_path):
    total = results.get('total', 0)
    entries = results.get('entries', [])
    matched = [e for e in entries if e['is_matched']]
    unmatched = [e for e in entries if not e['is_matched']]

    html_parts = []
    html_parts.append('<!doctype html><html><head><meta charset="utf-8"><title>Data source comparison report</title>')
    html_parts.append('<style> body{font-family:Arial,Helvetica,sans-serif;padding:20px} table.compare{border-collapse:collapse;width:100%;margin-bottom:10px} table.compare th{background:#eee} details{margin-bottom:6px;padding:4px} table{width:100%;border-collapse:collapse} th{background:#e6f2ff} td, th{border:1px solid #999;padding:6px}</style>')
    html_parts.append('</head><body>')
    html_parts.append(f'<h1>Data source comparison report</h1>')
    html_parts.append(f'<p>Total number of Data sources compared: <strong>{total}</strong><br>')
    html_parts.append(f'Total number of matched Data sources: <strong>{len(matched)}</strong><br>')
    html_parts.append(f'Total number of unmatched Data sources: <strong>{len(unmatched)}</strong></p>')

    # Unmatched section
    html_parts.append('<h2>List of Unmatched Data sources</h2>')
    if unmatched:
        html_parts.append('<ol>')
        for entry in unmatched:
            name = entry['name']
            comps = entry['comparisons']
            html_parts.append(f'<li><details><summary>{html.escape(name)}</summary>')
            # Column Comparison
            col = comps['columns']
            col_matches_html, col_diffs_html = build_column_tables_html(col['matches'], col['diffs'], col['only_pre'], col['only_post'])
            html_parts.append('<h4>Column Comparison</h4>')
            html_parts.append('<details><summary>Matches</summary>')
            html_parts.append(col_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(col_diffs_html)
            html_parts.append('</details>')

            # Metadata
            md = comps['metadata']
            md_matches_html, md_diffs_html = build_metadata_tables_html(md['matches'], md['diffs'], md['only_pre'], md['only_post'])
            html_parts.append('<h4>Metadata Comparison</h4>')
            html_parts.append('<details><summary>Matches</summary>')
            html_parts.append(md_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(md_diffs_html)
            html_parts.append('</details>')

            # XML
            xmlc = comps['xml']
            xml_matches_html, xml_diffs_html = build_xml_tables_html(xmlc['matches_by_path'], xmlc['diffs_by_path'])
            html_parts.append('<h4>XML Comparison</h4>')
            html_parts.append('<details><summary>Matches</summary>')
            html_parts.append(xml_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(xml_diffs_html)
            html_parts.append('</details>')

            html_parts.append('</details></li>')
        html_parts.append('</ol>')
    else:
        html_parts.append('<p><em>No unmatched data sources.</em></p>')

    # Matched section
    html_parts.append('<h2>List of Matched Data sources</h2>')
    if matched:
        html_parts.append('<ol>')
        for entry in matched:
            name = entry['name']
            comps = entry['comparisons']
            html_parts.append(f'<li><details open><summary>{html.escape(name)}</summary>')
            # Columns
            col = comps['columns']
            col_matches_html, col_diffs_html = build_column_tables_html(col['matches'], col['diffs'], col['only_pre'], col['only_post'])
            html_parts.append('<h4>Column Comparison</h4>')
            html_parts.append('<details open><summary>Matches</summary>')
            html_parts.append(col_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(col_diffs_html)
            html_parts.append('</details>')
            # Metadata
            md = comps['metadata']
            md_matches_html, md_diffs_html = build_metadata_tables_html(md['matches'], md['diffs'], md['only_pre'], md['only_post'])
            html_parts.append('<h4>Metadata Comparison</h4>')
            html_parts.append('<details open><summary>Matches</summary>')
            html_parts.append(md_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(md_diffs_html)
            html_parts.append('</details>')
            # XML
            xmlc = comps['xml']
            xml_matches_html, xml_diffs_html = build_xml_tables_html(xmlc['matches_by_path'], xmlc['diffs_by_path'])
            html_parts.append('<h4>XML Comparison</h4>')
            html_parts.append('<details open><summary>Matches</summary>')
            html_parts.append(xml_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(xml_diffs_html)
            html_parts.append('</details>')

            html_parts.append('</details></li>')
        html_parts.append('</ol>')
    else:
        html_parts.append('<p><em>No matched data sources.</em></p>')

    html_parts.append('</body></html>')
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(html_parts))
    print(f"INFO: Report written to {output_path}")


def compare_two_datasources(pre_tds_root, post_tds_root):
    pre_cols = get_columns(pre_tds_root)
    post_cols = get_columns(post_tds_root)
    col_matches, col_diffs, col_only_pre, col_only_post = compare_keyed_dicts(pre_cols, post_cols)

    pre_md = get_metadata_records(pre_tds_root)
    post_md = get_metadata_records(post_tds_root)
    md_matches, md_diffs, md_only_pre, md_only_post = compare_keyed_dicts(pre_md, post_md)

    pre_inner = parse_inner_xml_from_tds(pre_tds_root)
    post_inner = parse_inner_xml_from_tds(post_tds_root)
    pre_details = get_allowed_detail_values(pre_inner)
    post_details = get_allowed_detail_values(post_inner)

    matches_by_path, diffs_by_path = {}, {}
    for path in ALLOWED_DETAIL_PATHS:
        pre_list = pre_details.get(path, [])
        post_list = post_details.get(path, [])
        m, d = compare_lists_by_index(pre_list, post_list)
        matches_by_path[path], diffs_by_path[path] = m, d

    comparison_summary = {
        'columns': {'matches': col_matches, 'diffs': col_diffs, 'only_pre': col_only_pre, 'only_post': col_only_post},
        'metadata': {'matches': md_matches, 'diffs': md_diffs, 'only_pre': md_only_pre, 'only_post': md_only_post},
        'xml': {'matches_by_path': matches_by_path, 'diffs_by_path': diffs_by_path}
    }

    has_col_diff = bool(col_diffs or col_only_pre or col_only_post)
    has_md_diff = bool(md_diffs or md_only_pre or md_only_post)
    has_xml_diff = any(diffs_by_path[path] for path in ALLOWED_DETAIL_PATHS)
    is_matched = not (has_col_diff or has_md_diff or has_xml_diff)

    return comparison_summary, is_matched


def collect_tdsx_files(directory):
    files = {}
    if not directory or not os.path.isdir(directory):
        return files
    for fname in os.listdir(directory):
        if fname.lower().endswith('.tdsx'):
            key = os.path.splitext(fname)[0]
            files[key] = os.path.join(directory, fname)
    return files


def main():
    # === HARD-CODED PATHS (edit these to match your environment) ===
    pre_dir = r"C:\\Users\\mr05197\\PycharmProjects\\pythonProject\\Full Volume Release\\Downloaded Content\\ISTD - 31"
    post_dir = r"C:\\Users\\mr05197\\PycharmProjects\\pythonProject\\Full Volume Release\\Downloaded Content\\STD - FR"
    output_path = "datasource_comparison_report.html"
    # =============================================================

    pre_files = collect_tdsx_files(pre_dir)
    post_files = collect_tdsx_files(post_dir)
    print(f"DEBUG: Pre files = {len(pre_files)}, Post files = {len(post_files)}")
    if not pre_files and not post_files:
        print("WARNING: No .tdsx files found in either directory. Check the hard-coded paths.")

    all_keys = sorted(set(pre_files.keys()) | set(post_files.keys()))
    total = len(all_keys)
    entries = []

    for key in all_keys:
        pre_path = pre_files.get(key)
        post_path = post_files.get(key)
        print(f"DEBUG: Processing '{key}' -- pre: {bool(pre_path)} post: {bool(post_path)}")

        pre_root = None
        post_root = None
        if pre_path:
            t = extract_tds_from_tdsx(pre_path)
            if t is None:
                print(f"DEBUG: Failed to extract pre .tds for {key} from {pre_path}")
            pre_root = parse_tds_from_string(t) if t else None
        if post_path:
            t = extract_tds_from_tdsx(post_path)
            if t is None:
                print(f"DEBUG: Failed to extract post .tds for {key} from {post_path}")
            post_root = parse_tds_from_string(t) if t else None

        comps, is_matched = compare_two_datasources(pre_root, post_root)

        # Debug counts per data source
        col = comps['columns']
        md = comps['metadata']
        xmlc = comps['xml']
        col_match_count = len(col.get('matches') or [])
        col_diff_count = len(col.get('diffs') or []) + len(col.get('only_pre') or []) + len(col.get('only_post') or [])
        md_match_count = len(md.get('matches') or [])
        md_diff_count = len(md.get('diffs') or []) + len(md.get('only_pre') or []) + len(md.get('only_post') or [])
        xml_diff_count = sum(len(xmlc['diffs_by_path'].get(p, [])) for p in xmlc['diffs_by_path'])
        xml_match_count = sum(len(xmlc['matches_by_path'].get(p, [])) for p in xmlc['matches_by_path'])
        print(f"DEBUG: '{key}': cols matched={col_match_count}, cols diffs={col_diff_count}; "
              f"md matched={md_match_count}, md diffs={md_diff_count}; xml matched={xml_match_count}, xml diffs={xml_diff_count}; "
              f"is_matched={is_matched}")

        entries.append({'name': key, 'comparisons': comps, 'is_matched': is_matched})

    matched_count = sum(1 for e in entries if e['is_matched'])
    unmatched_count = sum(1 for e in entries if not e['is_matched'])
    print(f"DEBUG: Total={total}, Matched={matched_count}, Unmatched={unmatched_count}")

    results = {'total': total, 'entries': entries}
    generate_html_report(results, output_path)


if __name__ == '__main__':
    main()
