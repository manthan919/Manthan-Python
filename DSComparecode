#!/usr/bin/env python3
"""
tableau_datasource_compare.py

Updated to address requested fixes:
 - main() now clearly collects pre_files and post_files using collect_tdsx_files(path)
 - We store comparisons for every datasource (matched or unmatched) so matched list shows full tables
 - Column comparison correctly collects every <column> element keyed by <name> and reports matches and differences
 - If a column is present on both sides and values equal it will appear in Matches; if values differ it will appear in Differences
 - If a column exists only on one side it will appear in Differences (only_pre / only_post)
 - Details (XML) comparison strictly pulls allowed paths and compares values by list index; matches and diffs are shown separately

Usage:
    python tableau_datasource_compare.py --pre /path/to/pre_tdsx_dir \
        --post /path/to/post_tdsx_dir --output report.html

"""

import argparse
import os
import zipfile
import xml.etree.ElementTree as ET
from collections import defaultdict
import html

ALLOWED_DETAIL_PATHS = [
    "root/connection/relation/table",
    "root/connection/relation/text",
    "root/connection/named-connection/caption",
    "root/connection/named-connection/connection/schema",
    "root/connection/named-connection/connection/username",
    "root/object-graph/objects/object/properties/relation/table",
    "root/object-graph/objects/object/properties/relation/name",
]


def strip_namespace(elem):
    if elem is None:
        return
    if isinstance(elem.tag, str) and elem.tag.startswith("{"):
        elem.tag = elem.tag.split('}', 1)[1]
    for k in list(elem.attrib.keys()):
        if k.startswith('{'):
            newk = k.split('}', 1)[1]
            elem.attrib[newk] = elem.attrib.pop(k)
    for child in list(elem):
        strip_namespace(child)


def extract_tds_from_tdsx(tdsx_path):
    try:
        with zipfile.ZipFile(tdsx_path, 'r') as z:
            for name in z.namelist():
                if name.lower().endswith('.tds'):
                    with z.open(name) as f:
                        data = f.read()
                        return data.decode('utf-8', errors='replace')
    except Exception as e:
        print(f"Failed to read {tdsx_path}: {e}")
    return None


def parse_tds_from_string(tds_string):
    if not tds_string:
        return None
    try:
        root = ET.fromstring(tds_string)
        strip_namespace(root)
        return root
    except Exception:
        try:
            parser = ET.XMLParser(encoding='utf-8')
            root = ET.fromstring(tds_string.encode('utf-8'), parser=parser)
            strip_namespace(root)
            return root
        except Exception as e:
            print(f"Failed parsing TDS XML: {e}")
            return None


def get_columns(tds_root):
    """Return dict keyed by DB Field name (value of <name>). Values are dict with tableau_field_name and hidden.
    If <param-domain-type> exists we prefix the key with 'Parameter_'. Hidden defaults to 'No' unless 'true'."""
    columns = {}
    if tds_root is None:
        return columns
    for col in tds_root.findall('.//column'):
        name = (col.findtext('name') or '').strip()
        # If name empty, try alternate tags
        if not name:
            # try datasource columns where db-field-name exists
            name = (col.findtext('db-field-name') or '').strip()
        caption = (col.findtext('caption') or '').strip()
        hidden_raw = col.findtext('hidden')
        if hidden_raw is None:
            hidden = 'No'
        else:
            hidden_l = hidden_raw.strip().lower()
            hidden = 'Yes' if hidden_l in ('true', '1', 'yes') else 'No'
        is_parameter = col.find('param-domain-type') is not None
        db_field_name = name
        if is_parameter:
            db_field_name = f"Parameter_{db_field_name}"
        # ensure unique keys even if name empty by using caption fallback
        if not db_field_name:
            db_field_name = f"__unnamed_column__{len(columns)+1}"
        columns[db_field_name] = {'tableau_field_name': caption, 'hidden': hidden, 'is_parameter': is_parameter}
    return columns


def get_metadata_records(tds_root):
    results = {}
    if tds_root is None:
        return results
    # Look for metadata-record or metadata-records/record
    for rec in tds_root.findall('.//metadata-record'):
        remote_name = (rec.findtext('remote-name') or '').strip()
        local_name = (rec.findtext('local-name') or '').strip()
        local_type = (rec.findtext('local-type') or '').strip()
        if remote_name:
            results[remote_name] = {'local_name': local_name, 'local_type': local_type}
    if not results:
        for rec in tds_root.findall('.//metadata-records//record'):
            remote_name = (rec.findtext('remote-name') or '').strip()
            local_name = (rec.findtext('local-name') or '').strip()
            local_type = (rec.findtext('local-type') or '').strip()
            if remote_name:
                results[remote_name] = {'local_name': local_name, 'local_type': local_type}
    return results


def parse_inner_xml_from_tds(tds_root):
    if tds_root is None:
        return None
    # attempt to find explicit <xml> element first
    xml_elem = tds_root.find('.//xml')
    content = None
    if xml_elem is not None and xml_elem.text and xml_elem.text.strip():
        content = xml_elem.text.strip()
    if not content:
        conn = tds_root.find('.//connection')
        if conn is not None:
            parts = []
            for child in list(conn):
                try:
                    parts.append(ET.tostring(child, encoding='utf-8').decode('utf-8', errors='replace'))
                except Exception:
                    pass
            if parts:
                content = '<root>' + ''.join(parts) + '</root>'
    if not content:
        return None
    try:
        inner_root = ET.fromstring(content)
        strip_namespace(inner_root)
        return inner_root
    except Exception:
        try:
            inner_root = ET.fromstring(f"<root>{content}</root>")
            strip_namespace(inner_root)
            return inner_root
        except Exception as e:
            print(f"Failed to parse inner xml: {e}")
            return None


def get_allowed_detail_values(inner_root):
    results = {p: [] for p in ALLOWED_DETAIL_PATHS}
    if inner_root is None:
        return results
    for path in ALLOWED_DETAIL_PATHS:
        parts = path.split('/')
        # build xpath relative to inner_root
        xpath = './/' + '/'.join(parts[1:]) if parts[0] == inner_root.tag else './/' + '/'.join(parts)
        try:
            found = inner_root.findall(xpath)
        except Exception:
            found = inner_root.findall('.//' + parts[-1])
        for elem in found:
            text = elem.text.strip() if elem.text and elem.text.strip() else ''
            results[path].append(text)
    return results


def compare_keyed_dicts(pre_dict, post_dict):
    matches = []
    diffs = []
    only_pre = []
    only_post = []
    pre_keys = set(pre_dict.keys())
    post_keys = set(post_dict.keys())
    for k in sorted(pre_keys & post_keys):
        if pre_dict[k] == post_dict[k]:
            matches.append((k, pre_dict[k], post_dict[k]))
        else:
            diffs.append((k, pre_dict[k], post_dict[k]))
    for k in sorted(pre_keys - post_keys):
        only_pre.append((k, pre_dict[k]))
    for k in sorted(post_keys - pre_keys):
        only_post.append((k, post_dict[k]))
    return matches, diffs, only_pre, only_post


def compare_lists_by_index(pre_list, post_list):
    matches = []
    diffs = []
    maxlen = max(len(pre_list), len(post_list))
    for i in range(maxlen):
        pre_val = pre_list[i] if i < len(pre_list) else None
        post_val = post_list[i] if i < len(post_list) else None
        if pre_val == post_val:
            if pre_val is not None:
                matches.append((i, pre_val))
        else:
            diffs.append((i, pre_val, post_val))
    return matches, diffs


def build_column_tables_html(matches, diffs, only_pre, only_post, pre_label='Pre-Deployment', post_label='Post Deployment'):
    header = '''
<table class="compare" border="1" cellspacing="0" cellpadding="4">
<thead>
<tr><th rowspan="2">DB Field Name</th><th colspan="2">%s</th><th colspan="2">%s</th></tr>
<tr><th>Tableau Field Name</th><th>Hidden</th><th>Tableau Field Name</th><th>Hidden</th></tr>
</thead>
<tbody>
''' % (pre_label, post_label)
    footer = '</tbody></table>'

    # matches: list of (key, pre_val, post_val) where pre_val == post_val
    matches_rows = []
    for key, prev, postv in matches:
        pre_tf = html.escape(prev.get('tableau_field_name',''))
        pre_hidden = html.escape(prev.get('hidden',''))
        post_tf = html.escape(postv.get('tableau_field_name',''))
        post_hidden = html.escape(postv.get('hidden',''))
        matches_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    # diffs: list of (key, pre_val, post_val) where values differ
    diffs_rows = []
    for key, prev, postv in diffs:
        pre_tf = html.escape(prev.get('tableau_field_name','')) if prev else ''
        pre_hidden = html.escape(prev.get('hidden','')) if prev else ''
        post_tf = html.escape(postv.get('tableau_field_name','')) if postv else ''
        post_hidden = html.escape(postv.get('hidden','')) if postv else ''
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td>{post_tf}</td><td>{post_hidden}</td></tr>")
    # only_pre
    for key, prev in only_pre:
        pre_tf = html.escape(prev.get('tableau_field_name',''))
        pre_hidden = html.escape(prev.get('hidden',''))
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{pre_tf}</td><td>{pre_hidden}</td><td></td><td></td></tr>")
    # only_post
    for key, postv in only_post:
        post_tf = html.escape(postv.get('tableau_field_name',''))
        post_hidden = html.escape(postv.get('hidden',''))
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td></td><td></td><td>{post_tf}</td><td>{post_hidden}</td></tr>")

    matches_html = header + (''.join(matches_rows) if matches_rows else '<tr><td colspan="5"><em>No matching columns</em></td></tr>') + footer
    diffs_html = header + (''.join(diffs_rows) if diffs_rows else '<tr><td colspan="5"><em>No differences</em></td></tr>') + footer
    return matches_html, diffs_html


def build_metadata_tables_html(matches, diffs, only_pre, only_post, pre_label='Pre-Deployment', post_label='Post Deployment'):
    header = '''
<table class="compare" border="1" cellspacing="0" cellpadding="4">
<thead>
<tr><th rowspan="2">DB Field Name</th><th colspan="2">%s</th><th colspan="2">%s</th></tr>
<tr><th>Tableau Remote Field Name</th><th>Data type</th><th>Tableau Remote Field Name</th><th>Data type</th></tr>
</thead>
<tbody>
''' % (pre_label, post_label)
    footer = '</tbody></table>'
    matches_rows = []
    for key, prev, postv in matches:
        matches_rows.append(f"<tr><td>{html.escape(key)}</td><td>{html.escape(prev.get('local_name',''))}</td><td>{html.escape(prev.get('local_type',''))}</td><td>{html.escape(postv.get('local_name',''))}</td><td>{html.escape(postv.get('local_type',''))}</td></tr>")
    diffs_rows = []
    for key, prev, postv in diffs:
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{html.escape(prev.get('local_name',''))}</td><td>{html.escape(prev.get('local_type',''))}</td><td>{html.escape(postv.get('local_name',''))}</td><td>{html.escape(postv.get('local_type',''))}</td></tr>")
    for key, prev in only_pre:
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td>{html.escape(prev.get('local_name',''))}</td><td>{html.escape(prev.get('local_type',''))}</td><td></td><td></td></tr>")
    for key, postv in only_post:
        diffs_rows.append(f"<tr><td>{html.escape(key)}</td><td></td><td></td><td>{html.escape(postv.get('local_name',''))}</td><td>{html.escape(postv.get('local_type',''))}</td></tr>")
    matches_html = header + (''.join(matches_rows) if matches_rows else '<tr><td colspan="5"><em>No matching metadata</em></td></tr>') + footer
    diffs_html = header + (''.join(diffs_rows) if diffs_rows else '<tr><td colspan="5"><em>No differences</em></td></tr>') + footer
    return matches_html, diffs_html


def build_xml_tables_html(matches_by_path, diffs_by_path):
    def small_table_for_matches(path, matches):
        rows = []
        for idx, val in matches:
            rows.append(f"<tr><td>{html.escape(path)}</td><td>{idx}</td><td>{html.escape(val or '')}</td></tr>")
        if not rows:
            return f"<table border=1 cellpadding=4 cellspacing=0><thead><tr><th>Attribute</th><th>Index</th><th>Value</th></tr></thead><tbody><tr><td colspan=3><em>No matches</em></td></tr></tbody></table>"
        return f"<table border=1 cellpadding=4 cellspacing=0><thead><tr><th>Attribute</th><th>Index</th><th>Value</th></tr></thead><tbody>{''.join(rows)}</tbody></table>"
    def small_table_for_diffs(path, diffs):
        rows = []
        for idx, pre, post in diffs:
            rows.append(f"<tr><td>{html.escape(path)}</td><td>{idx}</td><td>{html.escape(pre or '')}</td><td>{html.escape(post or '')}</td></tr>")
        if not rows:
            return f"<table border=1 cellpadding=4 cellspacing=0><thead><tr><th>Attribute</th><th>Index</th><th>Pre</th><th>Post</th></tr></thead><tbody><tr><td colspan=4><em>No differences</em></td></tr></tbody></table>"
        return f"<table border=1 cellpadding=4 cellspacing=0><thead><tr><th>Attribute</th><th>Index</th><th>Pre</th><th>Post</th></tr></thead><tbody>{''.join(rows)}</tbody></table>"

    matches_parts = []
    diffs_parts = []
    for path in ALLOWED_DETAIL_PATHS:
        matches_parts.append(small_table_for_matches(path, matches_by_path.get(path, [])))
        diffs_parts.append(small_table_for_diffs(path, diffs_by_path.get(path, [])))
    return '
'.join(matches_parts), '
'.join(diffs_parts)


def generate_html_report(results, output_path):
    total = results.get('total', 0)
    all_entries = results.get('entries', [])
    matched = [e for e in all_entries if e['is_matched']]
    unmatched = [e for e in all_entries if not e['is_matched']]

    html_parts = []
    html_parts.append('<!doctype html><html><head><meta charset="utf-8"><title>Data source comparison report</title>')
    html_parts.append('<style> body{font-family:Arial,Helvetica,sans-serif;padding:20px} table.compare{border-collapse:collapse;width:100%;margin-bottom:10px} table.compare th{background:#eee} details{margin-bottom:6px;padding:4px}</style>')
    html_parts.append('</head><body>')
    html_parts.append(f'<h1>Data source comparison report</h1>')
    html_parts.append(f'<p>Total number of Data sources compared: <strong>{total}</strong><br>')
    html_parts.append(f'Total number of matched Data sources: <strong>{len(matched)}</strong><br>')
    html_parts.append(f'Total number of unmatched Data sources: <strong>{len(unmatched)}</strong></p>')

    html_parts.append('<h2>List of Unmatched Data sources</h2>')
    if unmatched:
        html_parts.append('<ol>')
        for entry in unmatched:
            name = entry['name']
            comps = entry['comparisons']
            html_parts.append(f'<li><details><summary>{html.escape(name)}</summary>')
            # Column Comparison
            col = comps['columns']
            col_matches_html, col_diffs_html = build_column_tables_html(col['matches'], col['diffs'], col['only_pre'], col['only_post'])
            html_parts.append('<h4>Column Comparison</h4>')
            html_parts.append('<details><summary>Matches</summary>')
            html_parts.append(col_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(col_diffs_html)
            html_parts.append('</details>')

            # Metadata
            md = comps['metadata']
            md_matches_html, md_diffs_html = build_metadata_tables_html(md['matches'], md['diffs'], md['only_pre'], md['only_post'])
            html_parts.append('<h4>Metadata Comparison</h4>')
            html_parts.append('<details><summary>Matches</summary>')
            html_parts.append(md_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(md_diffs_html)
            html_parts.append('</details>')

            # XML
            xmlc = comps['xml']
            xml_matches_html, xml_diffs_html = build_xml_tables_html(xmlc['matches_by_path'], xmlc['diffs_by_path'])
            html_parts.append('<h4>XML Comparison</h4>')
            html_parts.append('<details><summary>Matches</summary>')
            html_parts.append(xml_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(xml_diffs_html)
            html_parts.append('</details>')

            html_parts.append('</details></li>')
        html_parts.append('</ol>')
    else:
        html_parts.append('<p><em>No unmatched data sources.</em></p>')

    html_parts.append('<h2>List of Matched Data sources</h2>')
    if matched:
        html_parts.append('<ol>')
        for entry in matched:
            name = entry['name']
            comps = entry['comparisons']
            html_parts.append(f'<li><details><summary>{html.escape(name)}</summary>')
            # For matched, still show full comparison tables
            col = comps['columns']
            col_matches_html, col_diffs_html = build_column_tables_html(col['matches'], col['diffs'], col['only_pre'], col['only_post'])
            html_parts.append('<h4>Column Comparison</h4>')
            html_parts.append('<details open><summary>Matches</summary>')
            html_parts.append(col_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(col_diffs_html)
            html_parts.append('</details>')

            md = comps['metadata']
            md_matches_html, md_diffs_html = build_metadata_tables_html(md['matches'], md['diffs'], md['only_pre'], md['only_post'])
            html_parts.append('<h4>Metadata Comparison</h4>')
            html_parts.append('<details open><summary>Matches</summary>')
            html_parts.append(md_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(md_diffs_html)
            html_parts.append('</details>')

            xmlc = comps['xml']
            xml_matches_html, xml_diffs_html = build_xml_tables_html(xmlc['matches_by_path'], xmlc['diffs_by_path'])
            html_parts.append('<h4>XML Comparison</h4>')
            html_parts.append('<details open><summary>Matches</summary>')
            html_parts.append(xml_matches_html)
            html_parts.append('</details>')
            html_parts.append('<details><summary>Differences</summary>')
            html_parts.append(xml_diffs_html)
            html_parts.append('</details>')

            html_parts.append('</details></li>')
        html_parts.append('</ol>')
    else:
        html_parts.append('<p><em>No matched data sources.</em></p>')

    html_parts.append('</body></html>')
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('
'.join(html_parts))
    print(f"Report written to {output_path}")


def compare_two_datasources(pre_tds_root, post_tds_root):
    pre_cols = get_columns(pre_tds_root)
    post_cols = get_columns(post_tds_root)
    col_matches, col_diffs, col_only_pre, col_only_post = compare_keyed_dicts(pre_cols, post_cols)

    pre_md = get_metadata_records(pre_tds_root)
    post_md = get_metadata_records(post_tds_root)
    md_matches, md_diffs, md_only_pre, md_only_post = compare_keyed_dicts(pre_md, post_md)

    pre_inner = parse_inner_xml_from_tds(pre_tds_root)
    post_inner = parse_inner_xml_from_tds(post_tds_root)
    pre_details = get_allowed_detail_values(pre_inner)
    post_details = get_allowed_detail_values(post_inner)

    matches_by_path = {}
    diffs_by_path = {}
    for path in ALLOWED_DETAIL_PATHS:
        pre_list = pre_details.get(path, [])
        post_list = post_details.get(path, [])
        m, d = compare_lists_by_index(pre_list, post_list)
        matches_by_path[path] = m
        diffs_by_path[path] = d

    comparison_summary = {
        'columns': {'matches': col_matches, 'diffs': col_diffs, 'only_pre': col_only_pre, 'only_post': col_only_post},
        'metadata': {'matches': md_matches, 'diffs': md_diffs, 'only_pre': md_only_pre, 'only_post': md_only_post},
        'xml': {'matches_by_path': matches_by_path, 'diffs_by_path': diffs_by_path}
    }

    has_col_diff = bool(col_diffs or col_only_pre or col_only_post)
    has_md_diff = bool(md_diffs or md_only_pre or md_only_post)
    has_xml_diff = any(diffs_by_path[path] for path in ALLOWED_DETAIL_PATHS)
    is_matched = not (has_col_diff or has_md_diff or has_xml_diff)

    return comparison_summary, is_matched


def collect_tdsx_files(directory):
    files = {}
    if not directory or not os.path.isdir(directory):
        return files
    for fname in os.listdir(directory):
        if fname.lower().endswith('.tdsx'):
            key = os.path.splitext(fname)[0]
            files[key] = os.path.join(directory, fname)
    return files


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--pre', required=True, help='Directory containing pre-deployment .tdsx files')
    parser.add_argument('--post', required=True, help='Directory containing post-deployment .tdsx files')
    parser.add_argument('--output', default='datasource_comparison_report.html', help='Output HTML report path')
    args = parser.parse_args()

    # Collect files (as requested: pre_files = collect_tdsx_files(path), post_files = collect_tdsx_files(path))
    pre_files = collect_tdsx_files(args.pre)
    post_files = collect_tdsx_files(args.post)

    all_keys = sorted(set(pre_files.keys()) | set(post_files.keys()))
    total = len(all_keys)
    entries = []

    for key in all_keys:
        pre_path = pre_files.get(key)
        post_path = post_files.get(key)

        pre_root = None
        post_root = None
        if pre_path:
            pre_tds_str = extract_tds_from_tdsx(pre_path)
            pre_root = parse_tds_from_string(pre_tds_str) if pre_tds_str else None
        if post_path:
            post_tds_str = extract_tds_from_tdsx(post_path)
            post_root = parse_tds_from_string(post_tds_str) if post_tds_str else None

        comps, is_matched = compare_two_datasources(pre_root, post_root)
        entries.append({'name': key, 'comparisons': comps, 'is_matched': is_matched})

    results = {'total': total, 'entries': entries}
    generate_html_report(results, args.output)


if __name__ == '__main__':
    main()
